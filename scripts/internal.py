import asyncio
import codecs
from typing import Dict
from ytmusicapi import YTMusic

from scripts.youtube import Video


class YTM(YTMusic):
    def __init__(
        self,
        auth: str = None,
        user: str = None,
        proxies: dict = None,
        language: str = "en",
    ):
        super().__init__(auth=auth, user=user, proxies=proxies, language=language)

    """
    This method is derived from BrowsingMixin.get_song.
    It adds url key with direct stream URL to the result dictionary.
    Uses httpx.AsyncClient in place of requests.
    """

    async def getSong(self, videoId: str) -> Dict:
        song_meta = {
            "videoId": videoId
        }
        """
        Get the stream URL using derived YouTube class by parsing player_response & stream's ITAG.
        This method makes zero network requests (multiple additional requests being made by using vanilla PyTube & YTMusic). (*cough. Considering player JavaScript doesn't update out of nowhere)
        """
        video = await Video.getFormat(videoId)
        song_meta["url"] = video["url"]
        if not song_meta["url"]:
            song_meta["url"] = video["fallbackURL"]
        song_meta["title"] = video["title"]
        song_meta["lengthSeconds"] = int(video["duration"]["approxDuration"]) // 1000
        if video["description"].endswith("Auto-generated by YouTube."):
            try:
                description = video["description"].split("\n\n")
                for i, detail in enumerate(description):
                    description[i] = codecs.escape_decode(detail)[0].decode("utf_8")
                song_meta["provider"] = description[0].replace(
                    "Provided to YouTube by ", ""
                )
                song_meta["artists"] = [
                    artist for artist in description[1].split(" Â· ")[1:]
                ]
                song_meta["copyright"] = description[3]
                song_meta["release"] = (
                    None
                    if len(description) < 5
                    else description[4].replace("Released on: ", "")
                )
                song_meta["production"] = (
                    None
                    if len(description) < 6
                    else [pub for pub in description[5].split("\n")]
                )
            except (KeyError, IndexError):
                pass
        return song_meta

    async def searchYouTube(self, query, filter):
        return await self.__run(self.search, query, filter)

    async def getArtist(self, channelId):
        return await self.__run(self.get_artist, channelId)

    async def getAlbum(self, browseId):
        return await self.__run(self.get_album, browseId)

    async def getWatchPlaylist(self, videoId):
        return await self.__run(self.get_watch_playlist, videoId)

    async def getLyrics(self, watchPlaylistId):
        return await self.__run(self.get_lyrics, watchPlaylistId)

    async def __run(self, method, *args):
        loop = asyncio.get_event_loop()
        return await loop.run_in_executor(None, method, *args)
