import asyncio
import httpx
import codecs
from typing import Dict
from urllib.parse import parse_qs
import json
from ytmusicapi import YTMusic
from youtubesearchpython.__future__ import StreamURLFetcher

class YTM(YTMusic):
    def __init__(
        self,
        auth: str = None,
        user: str = None,
        proxies: dict = None,
        language: str = "en",
    ):
        super().__init__(auth=auth, user=user, proxies=proxies, language=language)
        self.fetcher = StreamURLFetcher()

    """
    This method is derived from BrowsingMixin.get_song.
    It adds url key with direct stream URL to the result dictionary.
    Uses httpx.AsyncClient in place of requests.
    """

    async def getSong(self, videoId: str) -> Dict:
        endpoint = "https://www.youtube.com/get_video_info"
        params = {"video_id": videoId, "hl": self.language, "el": "detailpage"}
        async with httpx.AsyncClient() as client:
            response = await client.get(
                endpoint, params=params, headers=self.headers, timeout=None
            )
        text = parse_qs(response.text)
        if "player_response" not in text:
            return text
        player_response = json.loads(text["player_response"][0])
        song_meta = player_response["videoDetails"]
        """
        Get the stream URL using derieved YouTube class by parsing player_response & stream's ITAG.
        This method makes zero network requests (multiple additional requests being made by using vanilla PyTube & YTMusic). (*cough. Considering player JavaScript doesn't update out of nowhere)
        """
        song_meta["url"] = await self.fetcher.get({"id": videoId, "streamingData": player_response["streamingData"]}, 251)
        song_meta["category"] = player_response["microformat"][
            "playerMicroformatRenderer"
        ]["category"]
        if song_meta["shortDescription"].endswith("Auto-generated by YouTube."):
            try:
                description = song_meta["shortDescription"].split("\n\n")
                for i, detail in enumerate(description):
                    description[i] = codecs.escape_decode(detail)[0].decode("utf-8")
                song_meta["provider"] = description[0].replace(
                    "Provided to YouTube by ", ""
                )
                song_meta["artists"] = [
                    artist for artist in description[1].split(" Â· ")[1:]
                ]
                song_meta["copyright"] = description[3]
                song_meta["release"] = (
                    None
                    if len(description) < 5
                    else description[4].replace("Released on: ", "")
                )
                song_meta["production"] = (
                    None
                    if len(description) < 6
                    else [pub for pub in description[5].split("\n")]
                )
            except (KeyError, IndexError):
                pass
        return song_meta

    async def searchYouTube(self, query, filter):
        return await self.__run(self.search, query, filter)

    async def getArtist(self, channelId):
        return await self.__run(self.get_artist, channelId)

    async def getAlbum(self, browseId):
        return await self.__run(self.get_album, browseId)

    async def getWatchPlaylist(self, videoId):
        return await self.__run(self.get_watch_playlist, videoId)

    async def getLyrics(self, watchPlaylistId):
        return await self.__run(self.get_lyrics, watchPlaylistId)

    async def __run(self, method, *args):
        loop = asyncio.get_event_loop()
        return await loop.run_in_executor(None, method, *args)
